#BlueJ class context
comment0.params=imageFileNameStr\ nextNode
comment0.target=ImageNode(java.lang.String,\ ImageNode)
comment0.text=\n\ Creates\ an\ image\ node\n\ \n\ @param\ imageFileNameStr\ the\ file\ name\ of\ the\ image\ to\ be\ represented\ by\ this\ node\n\ @param\ nextNode\ the\ reference\ to\ the\ next\ node\ in\ the\ list\n
comment1.params=
comment1.target=java.lang.String\ getFileName()
comment1.text=\n\ Returns\ the\ filename\ of\ the\ image.\ \n
comment10.params=target
comment10.target=ImageNode\ nodeBefore(ImageNode)
comment10.text=\n\ Returns\ the\ node\ before\ the\ provided\ node.\n\ \n\ Assumption\:\ The\ provided\ node\ is\ one\ of\ the\ successors\ of\ this\ node.\n\ \n\ @param\ target\ the\ node\ whose\ predecessor\ is\ required\ \n
comment11.params=target
comment11.target=ImageNode\ nodeBeforeIter(ImageNode)
comment11.text=\n\ \n\ Returns\ the\ node\ before\ the\ provided\ node,\ using\ an\ iterative\ approach\n\ \n\ For\ the\ core\ part\ of\ the\ assignment.\n\ \n\ Assumption\:\ The\ provided\ node\ is\ one\ of\ the\ successors\ of\ this\ node.\n\n\ @param\ target\ the\ node\ whose\ predecessor\ is\ required\ \n
comment12.params=target\ previous
comment12.target=ImageNode\ nodeBeforeRec(ImageNode,\ ImageNode)
comment12.text=\n\ Returns\ the\ node\ before\ the\ provided\ node,\ using\ a\ recursive\ approach\n\ \n\ For\ the\ completion\ part\ of\ the\ assignment.\n\ \n\ Assumption\:\ The\ provided\ node\ is\ one\ of\ the\ successors\ of\ this\ node.\n\ \n\ @param\ target\ the\ node\ whose\ predecessor\ is\ required\ \n
comment13.params=previous
comment13.target=void\ removeNodeUsingPrevious(ImageNode)
comment13.text=\n\ Removes\ the\ node\ at\ the\ cursor,\ given\ a\ reference\ to\ the\ previous\ node\n\ \n\ @param\ previous\ the\ node\ preceding\ this\ node\n
comment14.params=previous
comment14.target=ImageNode\ reverseUsingPrevious(ImageNode)
comment14.text=\n\ Reverses\ the\ order\ of\ the\ linked\ list\ starting\ at\ this\ node,\ \n\ so\ that\ the\ last\ node\ is\ now\ the\ first\ node,\ and\ \n\ and\ the\ second-to-last\ node\ is\ the\ second\ node,\ and\ so\ on\n\ \n\ For\ the\ challenge\ part\ of\ the\ assignment.\n\ \n\ This\ method\ should\ be\ called\ by\ method\ reverseRec\ in\ class\ Images.\n\ @return\ the\ new\ first\ node\ \ \n
comment2.params=
comment2.target=ImageNode\ getNext()
comment2.text=\ \n\ Returns\ the\ successor\ of\ this\ node.\n
comment3.params=newNext
comment3.target=void\ setNext(ImageNode)
comment3.text=\n\ Changes\ the\ successor\ of\ this\ node.\n
comment4.params=
comment4.target=boolean\ isEmpty()
comment5.params=
comment5.target=int\ count()
comment5.text=\n\ Returns\ the\ number\ of\ nodes\ in\ the\ list\ started\ by\ this\ node.\n\ \n\ Can\ be\ called\ from\ outside\ this\ class,\ and\ then\ switches\ between\ using\ the\ \n\ iterative\ or\ recursive\ private\ implementations\ of\ the\ method\ depending\ on\ the\ value\ of\ a\ boolean\ field\ in\ the\ \n\ SlideshowApp\ class.\n\n\ @return\ the\ number\ of\ nodes\ in\ the\ list\ starting\ at\ this\ node.\n
comment6.params=
comment6.target=int\ countIter()
comment6.text=\n\ Returns\ the\ number\ of\ elements\ in\ the\ list\ starting\ from\ this\ node,\ using\ an\ iterative\ approach\n\n\ For\ the\ core\ part\ of\ the\ assignment.\n\ \n
comment7.params=
comment7.target=int\ countRec()
comment7.text=\n\ Returns\ the\ number\ of\ elements\ in\ the\ list\ starting\ from\ this\ node,\ using\ a\ recursive\ approach\n\n\ For\ the\ completion\ part\ of\ the\ assignment.\n\ \n
comment8.params=newNode
comment8.target=void\ insertAfter(ImageNode)
comment8.text=\n\ Inserts\ a\ node\ after\ this\ node.\n\ \n\ @param\ newNode\ the\ node\ to\ be\ inserted\n
comment9.params=newNode\ cursor
comment9.target=void\ insertBefore(ImageNode,\ ImageNode)
comment9.text=\n\ Inserts\ a\ new\ node\ before\ the\ cursor\ position\n\ \n\ For\ the\ core\ part\ of\ the\ assignment.\n\ \n\ Assumption\:\ The\ cursor\ points\ to\ some\ node\ that\ is\ part\ of\ the\ list\ started\ by\ the\ successor\ of\ this\ node.\n\ In\ other\ words,\ the\ cursor\ cannot\ point\ to\ this\ node,\ but\ will\ point\ to\ one\ of\ the\ successors\ of\ this\ node.\n\ \n\ @param\ newNode\ the\ new\ node\ to\ be\ inserted\n\ @param\ cursor\ \ the\ position\ before\ which\ the\ node\ needs\ to\ be\ inserted\n\ \n\ HINT\:\ Make\ use\ of\ method\ 'nodeBefore'\ in\ order\ to\ find\ the\ node\ before\ the\ cursor.\n\ HINT\:\ Once\ you\ have\ the\ previous\ node,\ you\ can\ make\ use\ of\ method\ 'insertAfter'.\n\n
numComments=15
